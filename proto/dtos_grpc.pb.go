// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v4.23.4
// source: proto/dtos.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
	UsuarioService_CriarUsuario_FullMethodName     = "/musica_app.UsuarioService/CriarUsuario"
	UsuarioService_LerUsuario_FullMethodName       = "/musica_app.UsuarioService/LerUsuario"
	UsuarioService_AtualizarUsuario_FullMethodName = "/musica_app.UsuarioService/AtualizarUsuario"
	UsuarioService_DeletarUsuario_FullMethodName   = "/musica_app.UsuarioService/DeletarUsuario"
	UsuarioService_LerUsuarios_FullMethodName      = "/musica_app.UsuarioService/LerUsuarios"
)

// UsuarioServiceClient is the client API for UsuarioService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UsuarioServiceClient interface {
	CriarUsuario(ctx context.Context, in *Usuario, opts ...grpc.CallOption) (*Resposta, error)
	LerUsuario(ctx context.Context, in *UsuarioID, opts ...grpc.CallOption) (*Usuario, error)
	AtualizarUsuario(ctx context.Context, in *Usuario, opts ...grpc.CallOption) (*Resposta, error)
	DeletarUsuario(ctx context.Context, in *UsuarioID, opts ...grpc.CallOption) (*Resposta, error)
	LerUsuarios(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*UsuarioList, error)
}

type usuarioServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUsuarioServiceClient(cc grpc.ClientConnInterface) UsuarioServiceClient {
	return &usuarioServiceClient{cc}
}

func (c *usuarioServiceClient) CriarUsuario(ctx context.Context, in *Usuario, opts ...grpc.CallOption) (*Resposta, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Resposta)
	err := c.cc.Invoke(ctx, UsuarioService_CriarUsuario_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usuarioServiceClient) LerUsuario(ctx context.Context, in *UsuarioID, opts ...grpc.CallOption) (*Usuario, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Usuario)
	err := c.cc.Invoke(ctx, UsuarioService_LerUsuario_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usuarioServiceClient) AtualizarUsuario(ctx context.Context, in *Usuario, opts ...grpc.CallOption) (*Resposta, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Resposta)
	err := c.cc.Invoke(ctx, UsuarioService_AtualizarUsuario_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usuarioServiceClient) DeletarUsuario(ctx context.Context, in *UsuarioID, opts ...grpc.CallOption) (*Resposta, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Resposta)
	err := c.cc.Invoke(ctx, UsuarioService_DeletarUsuario_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usuarioServiceClient) LerUsuarios(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*UsuarioList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UsuarioList)
	err := c.cc.Invoke(ctx, UsuarioService_LerUsuarios_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UsuarioServiceServer is the server API for UsuarioService service.
// All implementations must embed UnimplementedUsuarioServiceServer
// for forward compatibility
type UsuarioServiceServer interface {
	CriarUsuario(context.Context, *Usuario) (*Resposta, error)
	LerUsuario(context.Context, *UsuarioID) (*Usuario, error)
	AtualizarUsuario(context.Context, *Usuario) (*Resposta, error)
	DeletarUsuario(context.Context, *UsuarioID) (*Resposta, error)
	LerUsuarios(context.Context, *Empty) (*UsuarioList, error)
	mustEmbedUnimplementedUsuarioServiceServer()
}

// UnimplementedUsuarioServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUsuarioServiceServer struct {
}

func (UnimplementedUsuarioServiceServer) CriarUsuario(context.Context, *Usuario) (*Resposta, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CriarUsuario not implemented")
}
func (UnimplementedUsuarioServiceServer) LerUsuario(context.Context, *UsuarioID) (*Usuario, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LerUsuario not implemented")
}
func (UnimplementedUsuarioServiceServer) AtualizarUsuario(context.Context, *Usuario) (*Resposta, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AtualizarUsuario not implemented")
}
func (UnimplementedUsuarioServiceServer) DeletarUsuario(context.Context, *UsuarioID) (*Resposta, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletarUsuario not implemented")
}
func (UnimplementedUsuarioServiceServer) LerUsuarios(context.Context, *Empty) (*UsuarioList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LerUsuarios not implemented")
}
func (UnimplementedUsuarioServiceServer) mustEmbedUnimplementedUsuarioServiceServer() {}

// UnsafeUsuarioServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UsuarioServiceServer will
// result in compilation errors.
type UnsafeUsuarioServiceServer interface {
	mustEmbedUnimplementedUsuarioServiceServer()
}

func RegisterUsuarioServiceServer(s grpc.ServiceRegistrar, srv UsuarioServiceServer) {
	s.RegisterService(&UsuarioService_ServiceDesc, srv)
}

func _UsuarioService_CriarUsuario_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Usuario)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsuarioServiceServer).CriarUsuario(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UsuarioService_CriarUsuario_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsuarioServiceServer).CriarUsuario(ctx, req.(*Usuario))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsuarioService_LerUsuario_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UsuarioID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsuarioServiceServer).LerUsuario(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UsuarioService_LerUsuario_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsuarioServiceServer).LerUsuario(ctx, req.(*UsuarioID))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsuarioService_AtualizarUsuario_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Usuario)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsuarioServiceServer).AtualizarUsuario(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UsuarioService_AtualizarUsuario_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsuarioServiceServer).AtualizarUsuario(ctx, req.(*Usuario))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsuarioService_DeletarUsuario_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UsuarioID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsuarioServiceServer).DeletarUsuario(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UsuarioService_DeletarUsuario_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsuarioServiceServer).DeletarUsuario(ctx, req.(*UsuarioID))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsuarioService_LerUsuarios_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsuarioServiceServer).LerUsuarios(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UsuarioService_LerUsuarios_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsuarioServiceServer).LerUsuarios(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// UsuarioService_ServiceDesc is the grpc.ServiceDesc for UsuarioService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UsuarioService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "musica_app.UsuarioService",
	HandlerType: (*UsuarioServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CriarUsuario",
			Handler:    _UsuarioService_CriarUsuario_Handler,
		},
		{
			MethodName: "LerUsuario",
			Handler:    _UsuarioService_LerUsuario_Handler,
		},
		{
			MethodName: "AtualizarUsuario",
			Handler:    _UsuarioService_AtualizarUsuario_Handler,
		},
		{
			MethodName: "DeletarUsuario",
			Handler:    _UsuarioService_DeletarUsuario_Handler,
		},
		{
			MethodName: "LerUsuarios",
			Handler:    _UsuarioService_LerUsuarios_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/dtos.proto",
}

const (
	MusicaService_CriarMusica_FullMethodName     = "/musica_app.MusicaService/CriarMusica"
	MusicaService_LerMusica_FullMethodName       = "/musica_app.MusicaService/LerMusica"
	MusicaService_AtualizarMusica_FullMethodName = "/musica_app.MusicaService/AtualizarMusica"
	MusicaService_DeletarMusica_FullMethodName   = "/musica_app.MusicaService/DeletarMusica"
	MusicaService_LerMusicas_FullMethodName      = "/musica_app.MusicaService/LerMusicas"
)

// MusicaServiceClient is the client API for MusicaService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MusicaServiceClient interface {
	CriarMusica(ctx context.Context, in *Musica, opts ...grpc.CallOption) (*Resposta, error)
	LerMusica(ctx context.Context, in *MusicaID, opts ...grpc.CallOption) (*Musica, error)
	AtualizarMusica(ctx context.Context, in *Musica, opts ...grpc.CallOption) (*Resposta, error)
	DeletarMusica(ctx context.Context, in *MusicaID, opts ...grpc.CallOption) (*Resposta, error)
	LerMusicas(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MusicaList, error)
}

type musicaServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMusicaServiceClient(cc grpc.ClientConnInterface) MusicaServiceClient {
	return &musicaServiceClient{cc}
}

func (c *musicaServiceClient) CriarMusica(ctx context.Context, in *Musica, opts ...grpc.CallOption) (*Resposta, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Resposta)
	err := c.cc.Invoke(ctx, MusicaService_CriarMusica_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *musicaServiceClient) LerMusica(ctx context.Context, in *MusicaID, opts ...grpc.CallOption) (*Musica, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Musica)
	err := c.cc.Invoke(ctx, MusicaService_LerMusica_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *musicaServiceClient) AtualizarMusica(ctx context.Context, in *Musica, opts ...grpc.CallOption) (*Resposta, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Resposta)
	err := c.cc.Invoke(ctx, MusicaService_AtualizarMusica_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *musicaServiceClient) DeletarMusica(ctx context.Context, in *MusicaID, opts ...grpc.CallOption) (*Resposta, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Resposta)
	err := c.cc.Invoke(ctx, MusicaService_DeletarMusica_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *musicaServiceClient) LerMusicas(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MusicaList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MusicaList)
	err := c.cc.Invoke(ctx, MusicaService_LerMusicas_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MusicaServiceServer is the server API for MusicaService service.
// All implementations must embed UnimplementedMusicaServiceServer
// for forward compatibility
type MusicaServiceServer interface {
	CriarMusica(context.Context, *Musica) (*Resposta, error)
	LerMusica(context.Context, *MusicaID) (*Musica, error)
	AtualizarMusica(context.Context, *Musica) (*Resposta, error)
	DeletarMusica(context.Context, *MusicaID) (*Resposta, error)
	LerMusicas(context.Context, *Empty) (*MusicaList, error)
	mustEmbedUnimplementedMusicaServiceServer()
}

// UnimplementedMusicaServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMusicaServiceServer struct {
}

func (UnimplementedMusicaServiceServer) CriarMusica(context.Context, *Musica) (*Resposta, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CriarMusica not implemented")
}
func (UnimplementedMusicaServiceServer) LerMusica(context.Context, *MusicaID) (*Musica, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LerMusica not implemented")
}
func (UnimplementedMusicaServiceServer) AtualizarMusica(context.Context, *Musica) (*Resposta, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AtualizarMusica not implemented")
}
func (UnimplementedMusicaServiceServer) DeletarMusica(context.Context, *MusicaID) (*Resposta, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletarMusica not implemented")
}
func (UnimplementedMusicaServiceServer) LerMusicas(context.Context, *Empty) (*MusicaList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LerMusicas not implemented")
}
func (UnimplementedMusicaServiceServer) mustEmbedUnimplementedMusicaServiceServer() {}

// UnsafeMusicaServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MusicaServiceServer will
// result in compilation errors.
type UnsafeMusicaServiceServer interface {
	mustEmbedUnimplementedMusicaServiceServer()
}

func RegisterMusicaServiceServer(s grpc.ServiceRegistrar, srv MusicaServiceServer) {
	s.RegisterService(&MusicaService_ServiceDesc, srv)
}

func _MusicaService_CriarMusica_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Musica)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MusicaServiceServer).CriarMusica(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MusicaService_CriarMusica_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MusicaServiceServer).CriarMusica(ctx, req.(*Musica))
	}
	return interceptor(ctx, in, info, handler)
}

func _MusicaService_LerMusica_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MusicaID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MusicaServiceServer).LerMusica(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MusicaService_LerMusica_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MusicaServiceServer).LerMusica(ctx, req.(*MusicaID))
	}
	return interceptor(ctx, in, info, handler)
}

func _MusicaService_AtualizarMusica_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Musica)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MusicaServiceServer).AtualizarMusica(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MusicaService_AtualizarMusica_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MusicaServiceServer).AtualizarMusica(ctx, req.(*Musica))
	}
	return interceptor(ctx, in, info, handler)
}

func _MusicaService_DeletarMusica_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MusicaID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MusicaServiceServer).DeletarMusica(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MusicaService_DeletarMusica_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MusicaServiceServer).DeletarMusica(ctx, req.(*MusicaID))
	}
	return interceptor(ctx, in, info, handler)
}

func _MusicaService_LerMusicas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MusicaServiceServer).LerMusicas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MusicaService_LerMusicas_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MusicaServiceServer).LerMusicas(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// MusicaService_ServiceDesc is the grpc.ServiceDesc for MusicaService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MusicaService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "musica_app.MusicaService",
	HandlerType: (*MusicaServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CriarMusica",
			Handler:    _MusicaService_CriarMusica_Handler,
		},
		{
			MethodName: "LerMusica",
			Handler:    _MusicaService_LerMusica_Handler,
		},
		{
			MethodName: "AtualizarMusica",
			Handler:    _MusicaService_AtualizarMusica_Handler,
		},
		{
			MethodName: "DeletarMusica",
			Handler:    _MusicaService_DeletarMusica_Handler,
		},
		{
			MethodName: "LerMusicas",
			Handler:    _MusicaService_LerMusicas_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/dtos.proto",
}

const (
	PlaylistService_CriarPlaylist_FullMethodName             = "/musica_app.PlaylistService/CriarPlaylist"
	PlaylistService_ListarPlaylistsPorUsuario_FullMethodName = "/musica_app.PlaylistService/ListarPlaylistsPorUsuario"
	PlaylistService_ListarMusicasPorPlaylist_FullMethodName  = "/musica_app.PlaylistService/ListarMusicasPorPlaylist"
	PlaylistService_ListarPlaylistsPorMusica_FullMethodName  = "/musica_app.PlaylistService/ListarPlaylistsPorMusica"
	PlaylistService_LerPlaylist_FullMethodName               = "/musica_app.PlaylistService/LerPlaylist"
	PlaylistService_LerPlaylists_FullMethodName              = "/musica_app.PlaylistService/LerPlaylists"
	PlaylistService_AtualizarPlaylist_FullMethodName         = "/musica_app.PlaylistService/AtualizarPlaylist"
	PlaylistService_DeletarPlaylist_FullMethodName           = "/musica_app.PlaylistService/DeletarPlaylist"
)

// PlaylistServiceClient is the client API for PlaylistService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PlaylistServiceClient interface {
	CriarPlaylist(ctx context.Context, in *Playlist, opts ...grpc.CallOption) (*Resposta, error)
	ListarPlaylistsPorUsuario(ctx context.Context, in *UsuarioID, opts ...grpc.CallOption) (*PlaylistList, error)
	ListarMusicasPorPlaylist(ctx context.Context, in *PlaylistID, opts ...grpc.CallOption) (*MusicaList, error)
	ListarPlaylistsPorMusica(ctx context.Context, in *MusicaID, opts ...grpc.CallOption) (*PlaylistList, error)
	LerPlaylist(ctx context.Context, in *PlaylistID, opts ...grpc.CallOption) (*Playlist, error)
	LerPlaylists(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PlaylistList, error)
	AtualizarPlaylist(ctx context.Context, in *Playlist, opts ...grpc.CallOption) (*Resposta, error)
	DeletarPlaylist(ctx context.Context, in *PlaylistID, opts ...grpc.CallOption) (*Resposta, error)
}

type playlistServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPlaylistServiceClient(cc grpc.ClientConnInterface) PlaylistServiceClient {
	return &playlistServiceClient{cc}
}

func (c *playlistServiceClient) CriarPlaylist(ctx context.Context, in *Playlist, opts ...grpc.CallOption) (*Resposta, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Resposta)
	err := c.cc.Invoke(ctx, PlaylistService_CriarPlaylist_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playlistServiceClient) ListarPlaylistsPorUsuario(ctx context.Context, in *UsuarioID, opts ...grpc.CallOption) (*PlaylistList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PlaylistList)
	err := c.cc.Invoke(ctx, PlaylistService_ListarPlaylistsPorUsuario_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playlistServiceClient) ListarMusicasPorPlaylist(ctx context.Context, in *PlaylistID, opts ...grpc.CallOption) (*MusicaList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MusicaList)
	err := c.cc.Invoke(ctx, PlaylistService_ListarMusicasPorPlaylist_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playlistServiceClient) ListarPlaylistsPorMusica(ctx context.Context, in *MusicaID, opts ...grpc.CallOption) (*PlaylistList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PlaylistList)
	err := c.cc.Invoke(ctx, PlaylistService_ListarPlaylistsPorMusica_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playlistServiceClient) LerPlaylist(ctx context.Context, in *PlaylistID, opts ...grpc.CallOption) (*Playlist, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Playlist)
	err := c.cc.Invoke(ctx, PlaylistService_LerPlaylist_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playlistServiceClient) LerPlaylists(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PlaylistList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PlaylistList)
	err := c.cc.Invoke(ctx, PlaylistService_LerPlaylists_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playlistServiceClient) AtualizarPlaylist(ctx context.Context, in *Playlist, opts ...grpc.CallOption) (*Resposta, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Resposta)
	err := c.cc.Invoke(ctx, PlaylistService_AtualizarPlaylist_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playlistServiceClient) DeletarPlaylist(ctx context.Context, in *PlaylistID, opts ...grpc.CallOption) (*Resposta, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Resposta)
	err := c.cc.Invoke(ctx, PlaylistService_DeletarPlaylist_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PlaylistServiceServer is the server API for PlaylistService service.
// All implementations must embed UnimplementedPlaylistServiceServer
// for forward compatibility
type PlaylistServiceServer interface {
	CriarPlaylist(context.Context, *Playlist) (*Resposta, error)
	ListarPlaylistsPorUsuario(context.Context, *UsuarioID) (*PlaylistList, error)
	ListarMusicasPorPlaylist(context.Context, *PlaylistID) (*MusicaList, error)
	ListarPlaylistsPorMusica(context.Context, *MusicaID) (*PlaylistList, error)
	LerPlaylist(context.Context, *PlaylistID) (*Playlist, error)
	LerPlaylists(context.Context, *Empty) (*PlaylistList, error)
	AtualizarPlaylist(context.Context, *Playlist) (*Resposta, error)
	DeletarPlaylist(context.Context, *PlaylistID) (*Resposta, error)
	mustEmbedUnimplementedPlaylistServiceServer()
}

// UnimplementedPlaylistServiceServer must be embedded to have forward compatible implementations.
type UnimplementedPlaylistServiceServer struct {
}

func (UnimplementedPlaylistServiceServer) CriarPlaylist(context.Context, *Playlist) (*Resposta, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CriarPlaylist not implemented")
}
func (UnimplementedPlaylistServiceServer) ListarPlaylistsPorUsuario(context.Context, *UsuarioID) (*PlaylistList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListarPlaylistsPorUsuario not implemented")
}
func (UnimplementedPlaylistServiceServer) ListarMusicasPorPlaylist(context.Context, *PlaylistID) (*MusicaList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListarMusicasPorPlaylist not implemented")
}
func (UnimplementedPlaylistServiceServer) ListarPlaylistsPorMusica(context.Context, *MusicaID) (*PlaylistList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListarPlaylistsPorMusica not implemented")
}
func (UnimplementedPlaylistServiceServer) LerPlaylist(context.Context, *PlaylistID) (*Playlist, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LerPlaylist not implemented")
}
func (UnimplementedPlaylistServiceServer) LerPlaylists(context.Context, *Empty) (*PlaylistList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LerPlaylists not implemented")
}
func (UnimplementedPlaylistServiceServer) AtualizarPlaylist(context.Context, *Playlist) (*Resposta, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AtualizarPlaylist not implemented")
}
func (UnimplementedPlaylistServiceServer) DeletarPlaylist(context.Context, *PlaylistID) (*Resposta, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletarPlaylist not implemented")
}
func (UnimplementedPlaylistServiceServer) mustEmbedUnimplementedPlaylistServiceServer() {}

// UnsafePlaylistServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PlaylistServiceServer will
// result in compilation errors.
type UnsafePlaylistServiceServer interface {
	mustEmbedUnimplementedPlaylistServiceServer()
}

func RegisterPlaylistServiceServer(s grpc.ServiceRegistrar, srv PlaylistServiceServer) {
	s.RegisterService(&PlaylistService_ServiceDesc, srv)
}

func _PlaylistService_CriarPlaylist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Playlist)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlaylistServiceServer).CriarPlaylist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PlaylistService_CriarPlaylist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlaylistServiceServer).CriarPlaylist(ctx, req.(*Playlist))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlaylistService_ListarPlaylistsPorUsuario_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UsuarioID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlaylistServiceServer).ListarPlaylistsPorUsuario(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PlaylistService_ListarPlaylistsPorUsuario_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlaylistServiceServer).ListarPlaylistsPorUsuario(ctx, req.(*UsuarioID))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlaylistService_ListarMusicasPorPlaylist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlaylistID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlaylistServiceServer).ListarMusicasPorPlaylist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PlaylistService_ListarMusicasPorPlaylist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlaylistServiceServer).ListarMusicasPorPlaylist(ctx, req.(*PlaylistID))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlaylistService_ListarPlaylistsPorMusica_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MusicaID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlaylistServiceServer).ListarPlaylistsPorMusica(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PlaylistService_ListarPlaylistsPorMusica_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlaylistServiceServer).ListarPlaylistsPorMusica(ctx, req.(*MusicaID))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlaylistService_LerPlaylist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlaylistID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlaylistServiceServer).LerPlaylist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PlaylistService_LerPlaylist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlaylistServiceServer).LerPlaylist(ctx, req.(*PlaylistID))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlaylistService_LerPlaylists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlaylistServiceServer).LerPlaylists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PlaylistService_LerPlaylists_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlaylistServiceServer).LerPlaylists(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlaylistService_AtualizarPlaylist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Playlist)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlaylistServiceServer).AtualizarPlaylist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PlaylistService_AtualizarPlaylist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlaylistServiceServer).AtualizarPlaylist(ctx, req.(*Playlist))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlaylistService_DeletarPlaylist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlaylistID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlaylistServiceServer).DeletarPlaylist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PlaylistService_DeletarPlaylist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlaylistServiceServer).DeletarPlaylist(ctx, req.(*PlaylistID))
	}
	return interceptor(ctx, in, info, handler)
}

// PlaylistService_ServiceDesc is the grpc.ServiceDesc for PlaylistService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PlaylistService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "musica_app.PlaylistService",
	HandlerType: (*PlaylistServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CriarPlaylist",
			Handler:    _PlaylistService_CriarPlaylist_Handler,
		},
		{
			MethodName: "ListarPlaylistsPorUsuario",
			Handler:    _PlaylistService_ListarPlaylistsPorUsuario_Handler,
		},
		{
			MethodName: "ListarMusicasPorPlaylist",
			Handler:    _PlaylistService_ListarMusicasPorPlaylist_Handler,
		},
		{
			MethodName: "ListarPlaylistsPorMusica",
			Handler:    _PlaylistService_ListarPlaylistsPorMusica_Handler,
		},
		{
			MethodName: "LerPlaylist",
			Handler:    _PlaylistService_LerPlaylist_Handler,
		},
		{
			MethodName: "LerPlaylists",
			Handler:    _PlaylistService_LerPlaylists_Handler,
		},
		{
			MethodName: "AtualizarPlaylist",
			Handler:    _PlaylistService_AtualizarPlaylist_Handler,
		},
		{
			MethodName: "DeletarPlaylist",
			Handler:    _PlaylistService_DeletarPlaylist_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/dtos.proto",
}
